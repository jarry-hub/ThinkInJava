#### description  
&emsp;&emsp;每一小结和例子的对应关系
	 
*** 
#### 3.1 等待/通知机制
##### 3.1.1 生产者/消费者模式实现
###### [一生产与一消费:操作栈](https://github.com/wooyeeyii/ThinkInJava/tree/master/MultipleThread/src/com/chapter3/P164)
###### [一生产与多消费:操作栈(ERROR)](https://github.com/wooyeeyii/ThinkInJava/tree/master/MultipleThread/src/com/chapter3/P167)
###### [一生产与多消费:操作栈(OK)](https://github.com/wooyeeyii/ThinkInJava/tree/master/MultipleThread/src/com/chapter3/P168)
###### [多生产与一消费:操作栈](https://github.com/wooyeeyii/ThinkInJava/tree/master/MultipleThread/src/com/chapter3/P169)
###### [多生产与多消费:操作栈](https://github.com/wooyeeyii/ThinkInJava/tree/master/MultipleThread/src/com/chapter3/P170)

#### 3.2 Join方法的使用
##### 3.2.5 [方法join(long)和sleep()的区别](https://github.com/wooyeeyii/ThinkInJava/tree/master/MultipleThread/src/com/chapter3/P184)
##### 3.2.6 [方法join()后面的代码提前运行：出现意外](https://github.com/wooyeeyii/ThinkInJava/tree/master/MultipleThread/src/com/chapter3/P187)

#### 3.3 类ThreadLocal的使用
##### 3.3.1 [方法get()与NULL](com.chapter3.P)
##### 3.3.1 [方法get()与NULL](com.chapter3.P)
##### 3.3.1 [方法get()与NULL](com.chapter3.P)

### 第四章 Lock的使用
#### 4.1 使用ReentrantLock类
##### 4.1.1 [使用ReentrantLock实现同步：测试1](https://github.com/wooyeeyii/ThinkInJava/tree/master/MultipleThread/src/com/chapter4/P200)
##### 4.1.2 [使用ReentrantLock实现同步：测试2](https://github.com/wooyeeyii/ThinkInJava/tree/master/MultipleThread/src/com/chapter4/P202)
##### 4.1.3 [使用Condition实现等待/通知:错误用法与解决](https://github.com/wooyeeyii/ThinkInJava/tree/master/MultipleThread/src/com/chapter4/P205)
##### 4.1.4 [正确使用Condition实现等待/通知](https://github.com/wooyeeyii/ThinkInJava/tree/master/MultipleThread/src/com/chapter4/P207)
##### 4.1.5 [使用多个Condition实现通知部分线程：错误用法](https://github.com/wooyeeyii/ThinkInJava/tree/master/MultipleThread/src/com/chapter4/P208)
##### 4.1.6 [使用多个Condition实现通知部分线程：正确用法](https://github.com/wooyeeyii/ThinkInJava/tree/master/MultipleThread/src/com/chapter4/P210)
##### 4.1.7 [实现生产者/消费者模式:一对一交替打印](https://github.com/wooyeeyii/ThinkInJava/tree/master/MultipleThread/src/com/chapter4/P213)
##### 4.1.8 [实现生产者/消费者模式:多对多交替打印](https://github.com/wooyeeyii/ThinkInJava/tree/master/MultipleThread/src/com/chapter4/P214)
##### 4.1.9 [公平锁和非公平锁](https://github.com/wooyeeyii/ThinkInJava/tree/master/MultipleThread/src/com/chapter4/P216)
##### 4.1.10 [方法getHoldCount()/getQueueLength()/getWaitQueueLength()的测试](https://github.com/wooyeeyii/ThinkInJava/tree/master/MultipleThread/src/com/chapter4/P216)
##### 4.1.11 [方法hasQueuedThread()/hasQueuedThreads()/hasWaiters()的测试](https://github.com/wooyeeyii/ThinkInJava/tree/master/MultipleThread/src/com/chapter4/P222)
##### 4.1.12 [方法isFair()/isHeldByCurrentThread()/isLocked()的测试](https://github.com/wooyeeyii/ThinkInJava/tree/master/MultipleThread/src/com/chapter4/P224)








